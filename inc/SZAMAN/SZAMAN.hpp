#pragma once
#include <iostream>
#include <filesystem>
#include <vector>
#include <list>
#include <locale>
#include <utility>
#include <unordered_map>
#include <fstream>
#include <cctype>
#include <string>

namespace szaman
{
	/// <summary>
	/// Initializes vector of bytes with zeros.
	/// </summary>
	/// <param name="vec">Reference to the vector</param>
	/// <param name="memSize">Target size</param>
	inline void initializeBytecodeVector(std::vector<char> &vec, std::size_t memSize)
	{
		for (std::size_t i = 0; i < memSize; i++)
		{
			vec.push_back(0);
		}
	}

	/// <summary>
	/// Counter of errors.
	/// </summary>
	static int errCnt = 0;

	/// <summary>
	/// Displays error using console.
	/// </summary>
	/// <param name="msg">Error message</param>
	/// <param name="code">Error code</param>
	/// <param name="line">Line where the error occured</param>
	/// <param name="file">File in which the error occured</param>
	/// <param name="showbadcode">Switch used to display erroneous assembly code</param>
	/// <param name="badCode">Erroneous assembly code</param>
	inline void displayError(std::string msg, std::string code, std::size_t line, std::string file, bool showbadcode, std::string badCode = "")
	{
		errCnt++;
		if (showbadcode == false)
			std::cout << "[ERR " << code << "] [" << file << "] [" << std::to_string(line) << "] " << msg << "\n\n";
		else
			std::cout << "[ERR " << code << "] [" << file << "] [" << std::to_string(line) << "] " << msg << ":\n\t" << badCode << "\n";
	}

	/// <summary>
	/// Converts text to lowercase.
	/// </summary>
	/// <param name="text">Text to be converted</param>
	/// <returns>Lowercase text</returns>
	inline std::string lowercase(std::string text)
	{
		for (std::size_t i = 0; i < text.length(); i++)
		{
			text[i] = std::tolower(text[i]);
		}
		return text;
	}

	/// <summary>
	/// Performs intial assembly step - line formatting.
	/// </summary>
	/// <param name="code">Code to be processed</param>
	/// <param name="line">Origin line</param>
	/// <param name="label">This bool is set to true if label was encountered</param>
	/// <param name="labelTxt">This string is set to the name of the encountered label</param>
	/// <param name="labelDeclared">This bool is set to true if label was declared</param>
	/// <param name="preprocessor">This bool is set to true if preprocessor instruction was encountered</param>
	/// <param name="file">Origin file</param>
	/// <param name="showbadcode">Set true to display erroneous assembly code in error messages</param>
	/// <returns></returns>
	inline uint16_t formatCode(std::string &code, std::size_t &line, bool &label, std::string &labelTxt, bool &labelDeclared, bool &preprocessor, std::string &file, bool showbadcode)
	{
		bool finished = false;
		bool removeSpace = true;
		uint16_t removedNumber = 0;
		int base = 0;
		bool numRemoval = false;
		bool labelExtraction = false;
		std::string labelRes = "";
		bool labelDeclaration = true;
		bool lockRemove = false;
		preprocessor = false;
		for (std::size_t i = 0; i < code.length(); i++)
		{
			if (finished == true)
			{
				code.erase(i, 1);
				i--;
				continue;
			}
			if (code[i] != '@' && code[i] != ' ' && code[i] != '\t' && code[i] != '.')
			{
				labelDeclaration = false;
			}
			if (labelExtraction == true)
			{
				if (code[i] == ';' || code[i] == ' ' || code[i] == '\t')
				{
					labelExtraction = false;
					finished = true;
					code.erase(i, 1);
					i--;
					continue;
				}
				else
				{
					labelRes += " ";
					labelRes.back() = code[i];
					code.erase(i, 1);
					i--;
					continue;
				}
			}
			if (numRemoval == true)
			{
				if ((code[i] < '0' || code[i] > '9') && (code[i] < 'a' || code[i] > 'f'))
				{
					numRemoval = false;
					base = 0;
				}
				else
				{
					if (base == 2)
					{
						removedNumber *= 2;
						removedNumber += code[i] - '0';
						code.erase(i, 1);
						i--;
					}
					else if (base == 10)
					{
						removedNumber *= 10;
						removedNumber += code[i] - '0';
						code.erase(i, 1);
						i--;
					}
					else if (base == 16)
					{
						removedNumber *= 16;
						if (code[i] <= '9')
						{
							removedNumber += code[i] - '0';
						}
						else
						{
							removedNumber += (code[i] - 'a') + 10;
						}
						code.erase(i, 1);
						i--;
					}
					else
					{
						displayError("Number base not specified.", "001", line, file, showbadcode, code);
					}
					continue;
				}
			}
			if (code[i] == ' ')
			{
				if (removeSpace == true)
				{
					code.erase(i, 1);
					i--;
				}
				removeSpace = true;
				continue;
			}
			if (code[i] == ',')
			{
				removeSpace = true;
				continue;
			}
			if (lockRemove == false)
			{
				removeSpace = false;
				lockRemove = true;
			}
			if (code[i] == '%')
			{
				numRemoval = true;
				code[i] = 'n';
				base = 2;
				continue;
			}
			if (code[i] == '$')
			{
				numRemoval = true;
				code[i] = 'n';
				base = 16;
				continue;
			}
			if (code[i] == '#')
			{
				numRemoval = true;
				code[i] = 'n';
				base = 10;
				continue;
			}
			if (code[i] == ';')
			{
				code.erase(i, 1);
				finished = true;
				i--;
				continue;
			}
			if (code[i] == '@')
			{
				if (labelDeclaration == true)
					labelDeclared = true;
				labelExtraction = true;
				label = true;
				code[i] = 'n';
				continue;
			}
			if (code[i] == '.')
			{
				if (labelDeclaration == false)
					displayError("Preprocessor instructions must be declared at the beginning of line.", "012", line, file, showbadcode, code);
				preprocessor = true;
				return 0;
			}
		}
		labelTxt = labelRes;
		if (code == "n")
		{
			code = "";
		}
		if (code.length() == 0)
			return removedNumber;
		for (std::size_t i = code.length() - 1; i >= 0; i--)
		{
			if (code[i] != ' ')
			{
				break;
			}
			else
			{
				code.erase(i);
			}
			if (i == 0)
				break;
		}
		return removedNumber;
	}

	/// <summary>
	/// This struct holds information about a single line of assembly code.
	/// </summary>
	struct CodeLine
	{
		std::string text;
		std::size_t position;
		std::string file;
		uint16_t removedNumber;
	};

	/// <summary>
	/// This unordered map contains all information necessary for machine code generation.
	/// </summary>
	static std::unordered_map<std::string, std::pair<uint32_t, uint8_t>> opcodes = {
		{"ld a,a", {0b01111111, 255}},
		{"ld a,b", {0b01111000, 255}},
		{"ld a,c", {0b01111001, 255}},
		{"ld a,d", {0b01111010, 255}},
		{"ld a,e", {0b01111011, 255}},
		{"ld a,h", {0b01111100, 255}},
		{"ld a,l", {0b01111101, 255}},

		{"ld b,a", {0b01000111, 255}},
		{"ld b,b", {0b01000000, 255}},
		{"ld b,c", {0b01000001, 255}},
		{"ld b,d", {0b01000010, 255}},
		{"ld b,e", {0b01000011, 255}},
		{"ld b,h", {0b01000100, 255}},
		{"ld b,l", {0b01000101, 255}},

		{"ld c,a", {0b01001111, 255}},
		{"ld c,b", {0b01001000, 255}},
		{"ld c,c", {0b01001011, 255}},
		{"ld c,d", {0b01001010, 255}},
		{"ld c,e", {0b01001011, 255}},
		{"ld c,h", {0b01001100, 255}},
		{"ld c,l", {0b01001101, 255}},

		{"ld d,a", {0b01010111, 255}},
		{"ld d,b", {0b01010000, 255}},
		{"ld d,c", {0b01010011, 255}},
		{"ld d,d", {0b01010010, 255}},
		{"ld d,e", {0b01010011, 255}},
		{"ld d,h", {0b01010100, 255}},
		{"ld d,l", {0b01010101, 255}},

		{"ld e,a", {0b01011111, 255}},
		{"ld e,b", {0b01011000, 255}},
		{"ld e,c", {0b01011011, 255}},
		{"ld e,d", {0b01011010, 255}},
		{"ld e,e", {0b01011011, 255}},
		{"ld e,h", {0b01011100, 255}},
		{"ld e,l", {0b01011101, 255}},

		{"ld h,a", {0b01100111, 255}},
		{"ld h,b", {0b01100000, 255}},
		{"ld h,c", {0b01100011, 255}},
		{"ld h,d", {0b01100010, 255}},
		{"ld h,e", {0b01100011, 255}},
		{"ld h,h", {0b01100100, 255}},
		{"ld h,l", {0b01100101, 255}},

		{"ld l,a", {0b01101111, 255}},
		{"ld l,b", {0b01101000, 255}},
		{"ld l,c", {0b01101011, 255}},
		{"ld l,d", {0b01101010, 255}},
		{"ld l,e", {0b01101011, 255}},
		{"ld l,h", {0b01101100, 255}},
		{"ld l,l", {0b01101101, 255}},

		{"ld a,n", {0b0011111000000000, 0}},
		{"ld b,n", {0b0000011000000000, 0}},
		{"ld c,n", {0b0000111000000000, 0}},
		{"ld d,n", {0b0001011000000000, 0}},
		{"ld e,n", {0b0001111000000000, 0}},
		{"ld h,n", {0b0010011000000000, 0}},
		{"ld l,n", {0b0010111000000000, 0}},

		{"ld a,(hl)", {0b01111110, 255}},
		{"ld b,(hl)", {0b01000110, 255}},
		{"ld c,(hl)", {0b01001110, 255}},
		{"ld d,(hl)", {0b01010110, 255}},
		{"ld e,(hl)", {0b01011110, 255}},
		{"ld h,(hl)", {0b01100110, 255}},
		{"ld l,(hl)", {0b01101110, 255}},

		{"ld a,(ix+n)", {0b110111010111111000000000, 0}},
		{"ld b,(ix+n)", {0b110111010100011000000000, 0}},
		{"ld c,(ix+n)", {0b110111010100111000000000, 0}},
		{"ld d,(ix+n)", {0b110111010101011000000000, 0}},
		{"ld e,(ix+n)", {0b110111010101111000000000, 0}},
		{"ld h,(ix+n)", {0b110111010110011000000000, 0}},
		{"ld l,(ix+n)", {0b110111010110111000000000, 0}},

		{"ld a,(iy+n)", {0b111111010111111000000000, 0}},
		{"ld b,(iy+n)", {0b111111010100011000000000, 0}},
		{"ld c,(iy+n)", {0b111111010100111000000000, 0}},
		{"ld d,(iy+n)", {0b111111010101011000000000, 0}},
		{"ld e,(iy+n)", {0b111111010101111000000000, 0}},
		{"ld h,(iy+n)", {0b111111010110011000000000, 0}},
		{"ld l,(iy+n)", {0b111111010110111000000000, 0}},

		{"ld (hl),a", {0b01110111, 255}},
		{"ld (hl),b", {0b01110000, 255}},
		{"ld (hl),c", {0b01110001, 255}},
		{"ld (hl),d", {0b01110010, 255}},
		{"ld (hl),e", {0b01110011, 255}},
		{"ld (hl),h", {0b01110100, 255}},
		{"ld (hl),l", {0b01110101, 255}},

		{"ld (ix+n),a", {0b110111010111011100000000, 0}},
		{"ld (ix+n),b", {0b110111010111000000000000, 0}},
		{"ld (ix+n),c", {0b110111010111000100000000, 0}},
		{"ld (ix+n),d", {0b110111010111001000000000, 0}},
		{"ld (ix+n),e", {0b110111010111001100000000, 0}},
		{"ld (ix+n),h", {0b110111010111010000000000, 0}},
		{"ld (ix+n),l", {0b110111010111010100000000, 0}},

		{"ld (iy+n),a", {0b111111010111011100000000, 0}},
		{"ld (iy+n),b", {0b111111010111000000000000, 0}},
		{"ld (iy+n),c", {0b111111010111000100000000, 0}},
		{"ld (iy+n),d", {0b111111010111001000000000, 0}},
		{"ld (iy+n),e", {0b111111010111001100000000, 0}},
		{"ld (iy+n),h", {0b111111010111010000000000, 0}},
		{"ld (iy+n),l", {0b111111010111010100000000, 0}},

		{"ld (hl),n", {0b0011011000000000, 0}},

		{"ld (ix+n),n", {0b11011101001101100000000000000000, 0}},

		{"ld (iy+n),n", {0b11111101001101100000000000000000, 0}},

		{"ld a,(bc)", {0b00001010, 255}},

		{"ld a,(de)", {0b00011010, 255}},

		{"ld a,(n)", {0b001110100000000000000000, 254}},

		{"ld (bc),a", {0b00000010, 255}},

		{"ld (de),a", {0b00010010, 255}},

		{"ld (n),a", {0b001100100000000000000000, 254}},

		{"ld a,i", {0b1110110101010111, 255}},

		{"ld a,r", {0b1110110101011111, 255}},

		{"ld i,a", {0b1110110101000111, 255}},

		{"ld r,a", {0b1110110101001111, 255}},

		{"ld bc,n", {0b000000010000000000000000, 254}},
		{"ld de,n", {0b000100010000000000000000, 254}},
		{"ld hl,n", {0b001000010000000000000000, 254}},
		{"ld sp,n", {0b001100010000000000000000, 254}},

		{"ld ix,n", {0b11011101001000010000000000000000, 254}},

		{"ld iy,n", {0b11111101001000010000000000000000, 254}},

		{"ld hl,(n)", {0b001010100000000000000000, 254}},

		{"ld n,(n)", {0b11101101010010110000000000000000, 254}},

		{"ld ix,(n)", {0b11011101001010100000000000000000, 254}},

		{"ld iy,(n)", {0b11111101001010100000000000000000, 254}},

		{"ld (n),hl", {0b001000100000000000000000, 254}},

		{"ld (n),bc", {0b11101101010000110000000000000000, 254}},
		{"ld (n),de", {0b11101101010100110000000000000000, 254}},
		{"ld (n),hl", {0b11101101011000110000000000000000, 254}},
		{"ld (n),sp", {0b11101101011100110000000000000000, 254}},

		{"ld (n),ix", {0b11011101001000100000000000000000, 254}},

		{"ld (n),iy", {0b11111101001000100000000000000000, 254}},

		{"ld sp,hl", {0b11111001, 255}},

		{"ld sp,ix", {0b1101110111111001, 255}},

		{"ld sp,iy", {0b1111110111111001, 255}},

		{"push bc", {0b11000101, 255}},
		{"push de", {0b11010101, 255}},
		{"push hl", {0b11100101, 255}},
		{"push af", {0b11110101, 255}},

		{"push ix", {0b1101110111100101, 255}},

		{"push iy", {0b1111110111100101, 255}},

		{"pop bc", {0b11000001, 255}},
		{"pop de", {0b11010001, 255}},
		{"pop hl", {0b11100001, 255}},
		{"pop af", {0b11110001, 255}},

		{"pop ix", {0b1101110111100001, 255}},

		{"pop iy", {0b1111110111100001, 255}},

		{"ex de,hl", {0b11101011, 255}},

		{"ex af,af'", {0b00001000, 255}},

		{"exx", {0b11011001, 255}},

		{"ex (sp),hl", {0b11100011, 255}},

		{"ex (sp),ix", {0b1101110111100011, 255}},

		{"ex (sp),iy", {0b1111110111100011, 255}},

		{"ldi", {0b1110110110100000, 255}},

		{"ldir", {0b1110110110110000, 255}},

		{"ldd", {0b1110110110101000, 255}},

		{"lddr", {0b1110110110111000, 255}},

		{"cpi", {0b1110110110100001, 255}},

		{"cpir", {0b1110110110110001, 255}},

		{"cpd", {0b1110110110101001, 255}},

		{"cpdr", {0b1110110110111001, 255}},

		{"add a,a", {0b10000111, 255}},
		{"add a,b", {0b10000000, 255}},
		{"add a,c", {0b10000001, 255}},
		{"add a,d", {0b10000010, 255}},
		{"add a,e", {0b10000011, 255}},
		{"add a,h", {0b10000100, 255}},
		{"add a,l", {0b10000101, 255}},

		{"add a,n", {0b1100011000000000, 0}},

		{"add a,(hl)", {0b10000110, 255}},

		{"add a,(ix+n)", {0b110111011000011000000000, 0}},

		{"add a,(iy+n)", {0b111111011000011000000000, 0}},

		{"adc a,a", {0b10001111, 255}},
		{"adc a,b", {0b10001000, 255}},
		{"adc a,c", {0b10001001, 255}},
		{"adc a,d", {0b10001010, 255}},
		{"adc a,e", {0b10001011, 255}},
		{"adc a,h", {0b10001100, 255}},
		{"adc a,l", {0b10001101, 255}},
		{"adc a,n", {0b1100111000000000, 0}},
		{"adc a,(hl)", {0b10001110, 255}},
		{"adc a,(ix+n)", {0b110111101000111000000000, 0}},
		{"adc a,(ix+n)", {0b111111011000111000000000, 0}},

		{"sub a", {0b10010111, 255}},
		{"sub b", {0b10010000, 255}},
		{"sub c", {0b10010001, 255}},
		{"sub d", {0b10010010, 255}},
		{"sub e", {0b10010011, 255}},
		{"sub h", {0b10010100, 255}},
		{"sub l", {0b10010101, 255}},
		{"sub n", {0b1101011000000000, 0}},
		{"sub (hl)", {0b10010110, 255}},
		{"sub (ix+n)", {0b110111011001011000000000, 0}},
		{"sub (iy+n)", {0b111111011001011000000000, 0}},

		{"sbc a,a", {0b10011111, 255}},
		{"sbc a,b", {0b10011000, 255}},
		{"sbc a,c", {0b10011001, 255}},
		{"sbc a,d", {0b10011010, 255}},
		{"sbc a,e", {0b10011011, 255}},
		{"sbc a,h", {0b10011100, 255}},
		{"sbc a,l", {0b10011101, 255}},
		{"sbc a,n", {0b1101111000000000, 0}},
		{"sbc a,(hl)", {0b10011110, 255}},
		{"sbc a,(ix+n)", {0b110111011001111000000000, 0}},
		{"sbc a,(ix+n)", {0b111111011001111000000000, 0}},

		{"and a", {0b10100111, 255}},
		{"and b", {0b10100000, 255}},
		{"and c", {0b10100001, 255}},
		{"and d", {0b10100010, 255}},
		{"and e", {0b10100011, 255}},
		{"and h", {0b10100100, 255}},
		{"and l", {0b10100101, 255}},
		{"and n", {0b1110011000000000, 0}},
		{"and (hl)", {0b10100110, 255}},
		{"and (ix+n)", {0b110111011010011000000000, 0}},
		{"and (ix+n)", {0b111111011010011000000000, 0}},

		{"or a", {0b10110111, 255}},
		{"or b", {0b10110000, 255}},
		{"or c", {0b10110001, 255}},
		{"or d", {0b10110010, 255}},
		{"or e", {0b10110011, 255}},
		{"or h", {0b10110100, 255}},
		{"or l", {0b10110101, 255}},
		{"or n", {0b1111011000000000, 0}},
		{"or (hl)", {0b10110110, 255}},
		{"or (ix+n)", {0b110111011011011000000000, 0}},
		{"or (ix+n)", {0b111111011011011000000000, 0}},

		{"xor a", {0b10101111, 255}},
		{"xor b", {0b10101000, 255}},
		{"xor c", {0b10101001, 255}},
		{"xor d", {0b10101010, 255}},
		{"xor e", {0b10101011, 255}},
		{"xor h", {0b10101100, 255}},
		{"xor l", {0b10101101, 255}},
		{"xor n", {0b1110111000000000, 0}},
		{"xor (hl)", {0b10101110, 255}},
		{"xor (ix+n)", {0b110111010111010100000000, 0}},
		{"xor (ix+n)", {0b111111010111010100000000, 0}},

		{"cp a", {0b10111111, 255}},
		{"cp b", {0b10111000, 255}},
		{"cp c", {0b10111001, 255}},
		{"cp d", {0b10111010, 255}},
		{"cp e", {0b10111011, 255}},
		{"cp h", {0b10111100, 255}},
		{"cp l", {0b10111101, 255}},
		{"cp n", {0b1111111000000000, 0}},
		{"cp (hl)", {0b10111110, 255}},
		{"cp (ix+n)", {0b110111011011111000000000, 0}},
		{"cp (ix+n)", {0b111111011011111000000000, 0}},

		{"inc a", {0b00111100, 255}},
		{"inc b", {0b00000100, 255}},
		{"inc c", {0b00001100, 255}},
		{"inc d", {0b00010100, 255}},
		{"inc e", {0b00011100, 255}},
		{"inc h", {0b00100100, 255}},
		{"inc l", {0b00101100, 255}},
		{"inc (hl)", {0b00110100, 255}},
		{"inc (ix+n)", {0b110111010011010000000000, 0}},
		{"inc (iy+n)", {0b111111010011010000000000, 0}},

		{"dec a", {0b00111101, 255}},
		{"dec b", {0b00000101, 255}},
		{"dec c", {0b00001101, 255}},
		{"dec d", {0b00010101, 255}},
		{"dec e", {0b00011101, 255}},
		{"dec h", {0b00100101, 255}},
		{"dec l", {0b00101101, 255}},
		{"dec (hl)", {0b00110101, 255}},
		{"dec (ix+n)", {0b110111010011010100000000, 0}},
		{"dec (iy+n)", {0b111111010011010100000000, 0}},

		{"daa", {0b00100111, 255}},

		{"cpl", {0b00101111, 255}},

		{"neg", {0b1110110101000100, 255}},

		{"ccf", {0b00111111, 255}},

		{"scf", {0b00110111, 255}},

		{"nop", {0b00000000, 255}},

		{"halt", {0b01110110, 255}},

		{"di", {0b11110011, 255}},

		{"ei", {0b11111011, 255}},

		{"im 0", {0b1110110101000110, 255}},

		{"im 1", {0b1110110101010110, 255}},

		{"im 2", {0b1110110101011110, 255}},

		{"add hl,bc", {0b00001001, 255}},
		{"add hl,de", {0b00011001, 255}},
		{"add hl,hl", {0b00101001, 255}},
		{"add hl,sp", {0b00111001, 255}},

		{"adc hl,bc", {0b1110110101001010, 255}},
		{"adc hl,de", {0b1110110101011010, 255}},
		{"adc hl,hl", {0b1110110101101010, 255}},
		{"adc hl,sp", {0b1110110101111010, 255}},

		{"sbc hl,bc", {0b1110110101000010, 255}},
		{"sbc hl,de", {0b1110110101010010, 255}},
		{"sbc hl,hl", {0b1110110101100010, 255}},
		{"sbc hl,sp", {0b1110110101110010, 255}},

		{"add ix,bc", {0b1101110100001001, 255}},
		{"add ix,de", {0b1101110100011001, 255}},
		{"add ix,ix", {0b1101110100101001, 255}},
		{"add ix,sp", {0b1101110100111001, 255}},

		{"add iy,bc", {0b1111110100001001, 255}},
		{"add iy,de", {0b1111110100011001, 255}},
		{"add iy,iy", {0b1111110100101001, 255}},
		{"add iy,sp", {0b1111110100111001, 255}},

		{"inc bc", {0b00000011, 255}},
		{"inc de", {0b00010011, 255}},
		{"inc hl", {0b00100011, 255}},
		{"inc sp", {0b00110011, 255}},

		{"inc ix", {0b1101110100100011, 255}},

		{"inc iy", {0b1111110100100011, 255}},

		{"dec bc", {0b00001011, 255}},
		{"dec de", {0b00011011, 255}},
		{"dec hl", {0b00101011, 255}},
		{"dec sp", {0b00111011, 255}},

		{"dec ix", {0b1101110100101011, 255}},

		{"dec iy", {0b1111110100101011, 255}},

		{"rlca", {0b00000111, 255}},

		{"rla", {0b00010111, 255}},

		{"rrca", {0b00001111, 255}},

		{"rra", {0b00011111, 255}},

		{"rlc a", {0b1100101100000111, 255}},
		{"rlc b", {0b1100101100000000, 255}},
		{"rlc c", {0b1100101100000001, 255}},
		{"rlc d", {0b1100101100000010, 255}},
		{"rlc e", {0b1100101100000011, 255}},
		{"rlc h", {0b1100101100000100, 255}},
		{"rlc l", {0b1100101100000101, 255}},

		{"rlc (hl)", {0b1100101100000110, 255}},

		{"rlc (ix+n)", {0b11011101110010110000000000000110, 8}},

		{"rlc (iy+n)", {0b11111101110010110000000000000110, 8}},

		{"rl a", {0b1100101100010111, 255}},
		{"rl b", {0b1100101100010000, 255}},
		{"rl c", {0b1100101100010001, 255}},
		{"rl d", {0b1100101100010010, 255}},
		{"rl e", {0b1100101100010011, 255}},
		{"rl h", {0b1100101100010100, 255}},
		{"rl l", {0b1100101100010101, 255}},
		{"rl (hl)", {0b1100101100010110, 255}},
		{"rl (ix+n)", {0b11011101110010110000000000010110, 8}},
		{"rl (iy+n)", {0b11111101110010110000000000010110, 8}},

		{"rrc a", {0b1100101100001111, 255}},
		{"rrc b", {0b1100101100001000, 255}},
		{"rrc c", {0b1100101100001001, 255}},
		{"rrc d", {0b1100101100001010, 255}},
		{"rrc e", {0b1100101100001011, 255}},
		{"rrc h", {0b1100101100001100, 255}},
		{"rrc l", {0b1100101100001101, 255}},
		{"rrc (hl)", {0b1100101100001110, 255}},
		{"rrc (ix+n)", {0b11011101110010110000000000001110, 8}},
		{"rrc (iy+n)", {0b11111101110010110000000000001110, 8}},

		{"rr a", {0b1100101100001111, 255}},
		{"rr b", {0b1100101100001000, 255}},
		{"rr c", {0b1100101100001001, 255}},
		{"rr d", {0b1100101100001010, 255}},
		{"rr e", {0b1100101100001011, 255}},
		{"rr h", {0b1100101100001100, 255}},
		{"rr l", {0b1100101100001101, 255}},
		{"rr (hl)", {0b1100101100011110, 255}},
		{"rr (ix+n)", {0b11011101110010110000000000011110, 8}},
		{"rr (iy+n)", {0b11111101110010110000000000011110, 8}},

		{"sla a", {0b1100101100100111, 255}},
		{"sla b", {0b1100101100100000, 255}},
		{"sla c", {0b1100101100100001, 255}},
		{"sla d", {0b1100101100100010, 255}},
		{"sla e", {0b1100101100100011, 255}},
		{"sla h", {0b1100101100100100, 255}},
		{"sla l", {0b1100101100100101, 255}},
		{"sla (hl)", {0b1100101100100110, 255}},
		{"sla (ix+n)", {0b11011101110010110000000000100110, 8}},
		{"sla (iy+n)", {0b11111101110010110000000000100110, 8}},

		{"sra a", {0b1100101100101111, 255}},
		{"sra b", {0b1100101100101000, 255}},
		{"sra c", {0b1100101100101001, 255}},
		{"sra d", {0b1100101100101010, 255}},
		{"sra e", {0b1100101100101011, 255}},
		{"sra h", {0b1100101100101100, 255}},
		{"sra l", {0b1100101100101101, 255}},
		{"sra (hl)", {0b1100101100101110, 255}},
		{"sra (ix+n)", {0b11011101110010110000000000101110, 8}},
		{"sra (iy+n)", {0b11111101110010110000000000101110, 8}},

		{"srl a", {0b1100101100111111, 255}},
		{"srl b", {0b1100101100111000, 255}},
		{"srl c", {0b1100101100111001, 255}},
		{"srl d", {0b1100101100111010, 255}},
		{"srl e", {0b1100101100111011, 255}},
		{"srl h", {0b1100101100111100, 255}},
		{"srl l", {0b1100101100111101, 255}},
		{"srl (hl)", {0b1100101100111110, 255}},
		{"srl (ix+n)", {0b11011101110010110000000000111110, 8}},
		{"srl (iy+n)", {0b11111101110010110000000000111110, 8}},

		{"rld", {0b1110110101101111, 255}},

		{"rrd", {0b1110110101100111, 255}},

		{"bit 0,a", {0b1100101101000111, 255}},
		{"bit 0,b", {0b1100101101000000, 255}},
		{"bit 0,c", {0b1100101101000001, 255}},
		{"bit 0,d", {0b1100101101000010, 255}},
		{"bit 0,e", {0b1100101101000011, 255}},
		{"bit 0,h", {0b1100101101000100, 255}},
		{"bit 0,l", {0b1100101101000101, 255}},

		{"bit 1,a", {0b1100101101001111, 255}},
		{"bit 1,b", {0b1100101101001000, 255}},
		{"bit 1,c", {0b1100101101001001, 255}},
		{"bit 1,d", {0b1100101101001010, 255}},
		{"bit 1,e", {0b1100101101001011, 255}},
		{"bit 1,h", {0b1100101101001100, 255}},
		{"bit 1,l", {0b1100101101001101, 255}},

		{"bit 2,a", {0b1100101101010111, 255}},
		{"bit 2,b", {0b1100101101010000, 255}},
		{"bit 2,c", {0b1100101101010001, 255}},
		{"bit 2,d", {0b1100101101010010, 255}},
		{"bit 2,e", {0b1100101101010011, 255}},
		{"bit 2,h", {0b1100101101010100, 255}},
		{"bit 2,l", {0b1100101101010101, 255}},

		{"bit 3,a", {0b1100101101011111, 255}},
		{"bit 3,b", {0b1100101101011000, 255}},
		{"bit 3,c", {0b1100101101011001, 255}},
		{"bit 3,d", {0b1100101101011010, 255}},
		{"bit 3,e", {0b1100101101011011, 255}},
		{"bit 3,h", {0b1100101101011100, 255}},
		{"bit 3,l", {0b1100101101011101, 255}},

		{"bit 4,a", {0b1100101101100111, 255}},
		{"bit 4,b", {0b1100101101100000, 255}},
		{"bit 4,c", {0b1100101101100001, 255}},
		{"bit 4,d", {0b1100101101100010, 255}},
		{"bit 4,e", {0b1100101101100011, 255}},
		{"bit 4,h", {0b1100101101100100, 255}},
		{"bit 4,l", {0b1100101101100101, 255}},

		{"bit 5,a", {0b1100101101101111, 255}},
		{"bit 5,b", {0b1100101101101000, 255}},
		{"bit 5,c", {0b1100101101101001, 255}},
		{"bit 5,d", {0b1100101101101010, 255}},
		{"bit 5,e", {0b1100101101101011, 255}},
		{"bit 5,h", {0b1100101101101100, 255}},
		{"bit 5,l", {0b1100101101101101, 255}},

		{"bit 6,a", {0b1100101101110111, 255}},
		{"bit 6,b", {0b1100101101110000, 255}},
		{"bit 6,c", {0b1100101101110001, 255}},
		{"bit 6,d", {0b1100101101110010, 255}},
		{"bit 6,e", {0b1100101101110011, 255}},
		{"bit 6,h", {0b1100101101110100, 255}},
		{"bit 6,l", {0b1100101101110101, 255}},

		{"bit 7,a", {0b1100101101111111, 255}},
		{"bit 7,b", {0b1100101101111000, 255}},
		{"bit 7,c", {0b1100101101111001, 255}},
		{"bit 7,d", {0b1100101101111010, 255}},
		{"bit 7,e", {0b1100101101111011, 255}},
		{"bit 7,h", {0b1100101101111100, 255}},
		{"bit 7,l", {0b1100101101111101, 255}},

		{"bit 0,(hl)", {0b1100101101000110, 255}},
		{"bit 1,(hl)", {0b1100101101001110, 255}},
		{"bit 2,(hl)", {0b1100101101010110, 255}},
		{"bit 3,(hl)", {0b1100101101011110, 255}},
		{"bit 4,(hl)", {0b1100101101100110, 255}},
		{"bit 5,(hl)", {0b1100101101101110, 255}},
		{"bit 6,(hl)", {0b1100101101110110, 255}},
		{"bit 7,(hl)", {0b1100101101111110, 255}},

		{"bit 0,(ix+n)", {0b11011101110010110000000001000110, 8}},
		{"bit 1,(ix+n)", {0b11011101110010110000000001001110, 8}},
		{"bit 2,(ix+n)", {0b11011101110010110000000001010110, 8}},
		{"bit 3,(ix+n)", {0b11011101110010110000000001011110, 8}},
		{"bit 4,(ix+n)", {0b11011101110010110000000001100110, 8}},
		{"bit 5,(ix+n)", {0b11011101110010110000000001101110, 8}},
		{"bit 6,(ix+n)", {0b11011101110010110000000001110110, 8}},
		{"bit 7,(ix+n)", {0b11011101110010110000000001111110, 8}},

		{"bit 0,(iy+n)", {0b11111101110010110000000001000110, 8}},
		{"bit 1,(iy+n)", {0b11111101110010110000000001001110, 8}},
		{"bit 2,(iy+n)", {0b11111101110010110000000001010110, 8}},
		{"bit 3,(iy+n)", {0b11111101110010110000000001011110, 8}},
		{"bit 4,(iy+n)", {0b11111101110010110000000001100110, 8}},
		{"bit 5,(iy+n)", {0b11111101110010110000000001101110, 8}},
		{"bit 6,(iy+n)", {0b11111101110010110000000001110110, 8}},
		{"bit 7,(iy+n)", {0b11111101110010110000000001111110, 8}},

		{"set 0,a", {0b1100101111000111, 255}},
		{"set 0,b", {0b1100101111000000, 255}},
		{"set 0,c", {0b1100101111000001, 255}},
		{"set 0,d", {0b1100101111000010, 255}},
		{"set 0,e", {0b1100101111000011, 255}},
		{"set 0,h", {0b1100101111000100, 255}},
		{"set 0,l", {0b1100101111000101, 255}},

		{"set 1,a", {0b1100101111001111, 255}},
		{"set 1,b", {0b1100101111001000, 255}},
		{"set 1,c", {0b1100101111001001, 255}},
		{"set 1,d", {0b1100101111001010, 255}},
		{"set 1,e", {0b1100101111001011, 255}},
		{"set 1,h", {0b1100101111001100, 255}},
		{"set 1,l", {0b1100101111001101, 255}},

		{"set 2,a", {0b1100101111010111, 255}},
		{"set 2,b", {0b1100101111010000, 255}},
		{"set 2,c", {0b1100101111010001, 255}},
		{"set 2,d", {0b1100101111010010, 255}},
		{"set 2,e", {0b1100101111010011, 255}},
		{"set 2,h", {0b1100101111010100, 255}},
		{"set 2,l", {0b1100101111010101, 255}},

		{"set 3,a", {0b1100101111011111, 255}},
		{"set 3,b", {0b1100101111011000, 255}},
		{"set 3,c", {0b1100101111011001, 255}},
		{"set 3,d", {0b1100101111011010, 255}},
		{"set 3,e", {0b1100101111011011, 255}},
		{"set 3,h", {0b1100101111011100, 255}},
		{"set 3,l", {0b1100101111011101, 255}},

		{"set 4,a", {0b1100101111100111, 255}},
		{"set 4,b", {0b1100101111100000, 255}},
		{"set 4,c", {0b1100101111100001, 255}},
		{"set 4,d", {0b1100101111100010, 255}},
		{"set 4,e", {0b1100101111100011, 255}},
		{"set 4,h", {0b1100101111100100, 255}},
		{"set 4,l", {0b1100101111100101, 255}},

		{"set 5,a", {0b1100101111101111, 255}},
		{"set 5,b", {0b1100101111101000, 255}},
		{"set 5,c", {0b1100101111101001, 255}},
		{"set 5,d", {0b1100101111101010, 255}},
		{"set 5,e", {0b1100101111101011, 255}},
		{"set 5,h", {0b1100101111101100, 255}},
		{"set 5,l", {0b1100101111101101, 255}},

		{"set 6,a", {0b1100101111110111, 255}},
		{"set 6,b", {0b1100101111110000, 255}},
		{"set 6,c", {0b1100101111110001, 255}},
		{"set 6,d", {0b1100101111110010, 255}},
		{"set 6,e", {0b1100101111110011, 255}},
		{"set 6,h", {0b1100101111110100, 255}},
		{"set 6,l", {0b1100101111110101, 255}},

		{"set 7,a", {0b1100101111111111, 255}},
		{"set 7,b", {0b1100101111111000, 255}},
		{"set 7,c", {0b1100101111111001, 255}},
		{"set 7,d", {0b1100101111111010, 255}},
		{"set 7,e", {0b1100101111111011, 255}},
		{"set 7,h", {0b1100101111111100, 255}},
		{"set 7,l", {0b1100101111111101, 255}},

		{"set 0,(hl)", {0b1100101111000110, 255}},
		{"set 1,(hl)", {0b1100101111001110, 255}},
		{"set 2,(hl)", {0b1100101111010110, 255}},
		{"set 3,(hl)", {0b1100101111011110, 255}},
		{"set 4,(hl)", {0b1100101111100110, 255}},
		{"set 5,(hl)", {0b1100101111101110, 255}},
		{"set 6,(hl)", {0b1100101111110110, 255}},
		{"set 7,(hl)", {0b1100101111111110, 255}},

		{"set 0,(ix+n)", {0b11011101110010110000000011000110, 8}},
		{"set 1,(ix+n)", {0b11011101110010110000000011001110, 8}},
		{"set 2,(ix+n)", {0b11011101110010110000000011010110, 8}},
		{"set 3,(ix+n)", {0b11011101110010110000000011011110, 8}},
		{"set 4,(ix+n)", {0b11011101110010110000000011100110, 8}},
		{"set 5,(ix+n)", {0b11011101110010110000000011101110, 8}},
		{"set 6,(ix+n)", {0b11011101110010110000000011110110, 8}},
		{"set 7,(ix+n)", {0b11011101110010110000000011111110, 8}},

		{"set 0,(iy+n)", {0b11111101110010110000000011000110, 8}},
		{"set 1,(iy+n)", {0b11111101110010110000000011001110, 8}},
		{"set 2,(iy+n)", {0b11111101110010110000000011010110, 8}},
		{"set 3,(iy+n)", {0b11111101110010110000000011011110, 8}},
		{"set 4,(iy+n)", {0b11111101110010110000000011100110, 8}},
		{"set 5,(iy+n)", {0b11111101110010110000000011101110, 8}},
		{"set 6,(iy+n)", {0b11111101110010110000000011110110, 8}},
		{"set 7,(iy+n)", {0b11111101110010110000000011111110, 8}},

		{"res 0,a", {0b1100101110000111, 255}},
		{"res 0,b", {0b1100101110000000, 255}},
		{"res 0,c", {0b1100101110000001, 255}},
		{"res 0,d", {0b1100101110000010, 255}},
		{"res 0,e", {0b1100101110000011, 255}},
		{"res 0,h", {0b1100101110000100, 255}},
		{"res 0,l", {0b1100101110000101, 255}},

		{"res 1,a", {0b1100101110001111, 255}},
		{"res 1,b", {0b1100101110001000, 255}},
		{"res 1,c", {0b1100101110001001, 255}},
		{"res 1,d", {0b1100101110001010, 255}},
		{"res 1,e", {0b1100101110001011, 255}},
		{"res 1,h", {0b1100101110001100, 255}},
		{"res 1,l", {0b1100101110001101, 255}},

		{"res 2,a", {0b1100101110010111, 255}},
		{"res 2,b", {0b1100101110010000, 255}},
		{"res 2,c", {0b1100101110010001, 255}},
		{"res 2,d", {0b1100101110010010, 255}},
		{"res 2,e", {0b1100101110010011, 255}},
		{"res 2,h", {0b1100101110010100, 255}},
		{"res 2,l", {0b1100101110010101, 255}},

		{"res 3,a", {0b1100101110011111, 255}},
		{"res 3,b", {0b1100101110011000, 255}},
		{"res 3,c", {0b1100101110011001, 255}},
		{"res 3,d", {0b1100101110011010, 255}},
		{"res 3,e", {0b1100101110011011, 255}},
		{"res 3,h", {0b1100101110011100, 255}},
		{"res 3,l", {0b1100101110011101, 255}},

		{"res 4,a", {0b1100101110100111, 255}},
		{"res 4,b", {0b1100101110100000, 255}},
		{"res 4,c", {0b1100101110100001, 255}},
		{"res 4,d", {0b1100101110100010, 255}},
		{"res 4,e", {0b1100101110100011, 255}},
		{"res 4,h", {0b1100101110100100, 255}},
		{"res 4,l", {0b1100101110100101, 255}},

		{"res 5,a", {0b1100101110101111, 255}},
		{"res 5,b", {0b1100101110101000, 255}},
		{"res 5,c", {0b1100101110101001, 255}},
		{"res 5,d", {0b1100101110101010, 255}},
		{"res 5,e", {0b1100101110101011, 255}},
		{"res 5,h", {0b1100101110101100, 255}},
		{"res 5,l", {0b1100101110101101, 255}},

		{"res 6,a", {0b1100101110110111, 255}},
		{"res 6,b", {0b1100101110110000, 255}},
		{"res 6,c", {0b1100101110110001, 255}},
		{"res 6,d", {0b1100101110110010, 255}},
		{"res 6,e", {0b1100101110110011, 255}},
		{"res 6,h", {0b1100101110110100, 255}},
		{"res 6,l", {0b1100101110110101, 255}},

		{"res 7,a", {0b1100101110111111, 255}},
		{"res 7,b", {0b1100101110111000, 255}},
		{"res 7,c", {0b1100101110111001, 255}},
		{"res 7,d", {0b1100101110111010, 255}},
		{"res 7,e", {0b1100101110111011, 255}},
		{"res 7,h", {0b1100101110111100, 255}},
		{"res 7,l", {0b1100101110111101, 255}},

		{"res 0,(hl)", {0b1100101110000110, 255}},
		{"res 1,(hl)", {0b1100101110001110, 255}},
		{"res 2,(hl)", {0b1100101110010110, 255}},
		{"res 3,(hl)", {0b1100101110011110, 255}},
		{"res 4,(hl)", {0b1100101110100110, 255}},
		{"res 5,(hl)", {0b1100101110101110, 255}},
		{"res 6,(hl)", {0b1100101110110110, 255}},
		{"res 7,(hl)", {0b1100101110111110, 255}},

		{"res 0,(ix+n)", {0b11011101110010110000000010000110, 8}},
		{"res 1,(ix+n)", {0b11011101110010110000000010001110, 8}},
		{"res 2,(ix+n)", {0b11011101110010110000000010010110, 8}},
		{"res 3,(ix+n)", {0b11011101110010110000000010011110, 8}},
		{"res 4,(ix+n)", {0b11011101110010110000000010100110, 8}},
		{"res 5,(ix+n)", {0b11011101110010110000000010101110, 8}},
		{"res 6,(ix+n)", {0b11011101110010110000000010110110, 8}},
		{"res 7,(ix+n)", {0b11011101110010110000000010111110, 8}},

		{"res 0,(iy+n)", {0b11111101110010110000000010000110, 8}},
		{"res 1,(iy+n)", {0b11111101110010110000000010001110, 8}},
		{"res 2,(iy+n)", {0b11111101110010110000000010010110, 8}},
		{"res 3,(iy+n)", {0b11111101110010110000000010011110, 8}},
		{"res 4,(iy+n)", {0b11111101110010110000000010100110, 8}},
		{"res 5,(iy+n)", {0b11111101110010110000000010101110, 8}},
		{"res 6,(iy+n)", {0b11111101110010110000000010110110, 8}},
		{"res 7,(iy+n)", {0b11111101110010110000000010111110, 8}},

		{"jp n", {0b110000110000000000000000, 254}},

		{"jp nz,n", {0b110000100000000000000000, 254}},
		{"jp z,n", {0b110010100000000000000000, 254}},
		{"jp nc,n", {0b110100100000000000000000, 254}},
		{"jp c,n", {0b110110100000000000000000, 254}},
		{"jp po,n", {0b111000100000000000000000, 254}},
		{"jp pe,n", {0b111010100000000000000000, 254}},
		{"jp p,n", {0b111100100000000000000000, 254}},
		{"jp m,n", {0b111110100000000000000000, 254}},

		{"jr n", {0b0001100000000000, 0}},

		{"jr c,n", {0b0011100000000000, 0}},

		{"jr nc,n", {0b0011000000000000, 0}},

		{"jr z,n", {0b0010100000000000, 0}},

		{"jr nz,n", {0b0010000000000000, 0}},

		{"jp (hl)", {0b11101001, 255}},

		{"jp (ix)", {0b1101110111101001, 255}},

		{"jp (iy)", {0b1111110111101001, 255}},

		{"djnz, n", {0b0001000000000000, 0}},
		{"djnz n", {0b0001000000000000, 0}},

		{"call n", {0b110011010000000000000000, 254}},

		{"call nz,n", {0b110001000000000000000000, 254}},
		{"call z,n", {0b110011000000000000000000, 254}},
		{"call nc,n", {0b110101000000000000000000, 254}},
		{"call c,n", {0b110111000000000000000000, 254}},
		{"call po,n", {0b111001000000000000000000, 254}},
		{"call pe,n", {0b111011000000000000000000, 254}},
		{"call p,n", {0b111101000000000000000000, 254}},
		{"call m,n", {0b111111000000000000000000, 254}},

		{"ret", {0b11001001, 255}},

		{"ret nz", {0b11000000, 0}},
		{"ret z", {0b11001000, 0}},
		{"ret nc", {0b11010000, 0}},
		{"ret c", {0b11011000, 0}},
		{"ret po", {0b11100000, 0}},
		{"ret pe", {0b11101000, 0}},
		{"ret p", {0b11110000, 0}},
		{"ret m", {0b11111000, 0}},

		{"reti", {0b1110110101001101, 255}},

		{"retn", {0b1110110101000101, 255}},

		{"rst n", {0b11000111, 3}},

		{"in a,(n)", {0b1101101100000000, 0}},

		{"in a,(c)", {0b1110110101111000, 255}},
		{"in b,(c)", {0b1110110101000000, 255}},
		{"in c,(c)", {0b1110110101001000, 255}},
		{"in d,(c)", {0b1110110101010000, 255}},
		{"in e,(c)", {0b1110110101011000, 255}},
		{"in h,(c)", {0b1110110101100000, 255}},
		{"in l,(c)", {0b1110110101101000, 255}},

		{"ini", {0b1110110110100010, 255}},

		{"inir", {0b1110110110110010, 255}},

		{"ind", {0b1110110110101010, 255}},

		{"indr", {0b1110110110111010, 255}},

		{"out (n),a", {0b1101001100000000, 0}},

		{"out (c),a", {0b1110110101111001, 255}},
		{"out (c),b", {0b1110110101000001, 255}},
		{"out (c),c", {0b1110110101001001, 255}},
		{"out (c),d", {0b1110110101010001, 255}},
		{"out (c),e", {0b1110110101011001, 255}},
		{"out (c),h", {0b1110110101100001, 255}},
		{"out (c),l", {0b1110110101101001, 255}},

		{"outi", {0b1110110110100011, 255}},

		{"otir", {0b1110110110110011, 255}},
		{"outir", {0b1110110110110011, 255}},

		{"outd", {0b1110110110101011, 255}},

		{"otdr", {0b1110110110111011, 255}},
		{"outdr", {0b1110110110111011, 255}},

		// Custom instruction
		{"raw n", {0, 254}}};

	/// <summary>
	/// Inserts macros.
	/// </summary>
	/// <param name="code">Assembly code</param>
	/// <param name="defines">Map of defines</param>
	/// <param name="codePos">Current position in code</param>
	/// <param name="line">Origin line</param>
	/// <param name="file">Origin file</param>
	/// <param name="showbadcode">Set true to show show erroneous code in error messages</param>
	inline void insertDefines(std::vector<CodeLine> &code, std::unordered_map<std::string, std::vector<std::string>> &defines, std::size_t codePos, std::size_t line, std::string &file, bool showbadcode)
	{
		std::string buf = lowercase(code[codePos].text);
		bool inserted = false;
		for (auto it = defines.begin(); it != defines.end(); it++)
		{
			std::size_t pos = 0;
			while (true)
			{
				if (it->first.length() == 0)
				{
					displayError("Macro names cannot contain names of other macros, defines or variables.", "999", line, file, showbadcode, buf);
					break;
				}
				pos = buf.find(it->first, pos);
				if (pos == std::string::npos)
					break;
				if (pos > 0)
				{
					if ((buf[pos - 1] != ',') && (buf[pos - 1] != ' ') && (buf[pos - 1] != '\t') && (buf[pos - 1] != '('))
					{
						pos++;
						continue;
					}
				}
				if (pos + it->first.length() < buf.length())
				{
					if ((buf[pos + it->first.length()] != ',') && (buf[pos + it->first.length()] != ' ') && (buf[pos + it->first.length()] != '\t') && (buf[pos + it->first.length()] != '#') && (buf[pos + it->first.length()] != '%') && (buf[pos + it->first.length()] != '$') && (buf[pos + it->first.length()] != ';') && (buf[pos + it->first.length()] != ')'))
					{
						pos++;
						continue;
					}
				}
				buf.erase(pos, it->first.length());
				std::size_t off = 0, off2 = 0;
				inserted = true;
				for (std::size_t o = 0; o < it->second.size(); o++)
				{
					if ((it->second.size() == 1) || (o == 0))
					{
						buf.insert(pos + off, it->second[o]);
						off += it->second[o].length() + 1;
					}
					else
					{
						CodeLine cl = code[codePos];
						cl.text = it->second[o];
						code.insert(code.begin() + codePos + off2 + 1, cl);
						off2++;
					}
				}
				pos++;
			}
		}
		code[codePos].text = buf;
		if (inserted == true)
			insertDefines(code, defines, codePos, line, file, showbadcode); // In case a macro was present in inserted one
	}

	/// <summary>
	/// Inserts variables.
	///
	/// WARNING: VARIABLES CURRENTLY NOT WORKING AS EXPECTED
	/// </summary>
	/// <param name="code">Assembly code</param>
	/// <param name="variables">Vector of variables</param>
	/// <param name="codePos">Current position in code</param>
	/// <param name="line">Origin line</param>
	/// <param name="file">Origin file</param>
	/// <param name="showbadcode">Set true to show show erroneous code in error messages</param>
	inline void insertVariables(std::vector<CodeLine> &code, std::vector<std::pair<std::string, int>> &variables, std::size_t codePos, std::size_t line, std::string &file, bool showbadcode)
	{
		std::string buf = lowercase(code[codePos].text);
		bool inserted = false;
		for (std::size_t i = 0; i < variables.size(); i++)
		{
			std::size_t pos = 0;
			while (true)
			{
				if (variables[i].first.length() == 0)
				{
					displayError("Variable names cannot contain names of other macros, defines or variables.", "998", line, file, showbadcode, buf);
					break;
				}
				pos = buf.find(variables[i].first, pos);
				if (pos == std::string::npos)
					break;
				buf.erase(pos, variables[i].first.length());
				buf.insert(pos, variables[i].second == 8 ? "B" : "BC");
				code[codePos].text = buf;
				CodeLine cl;
				cl.file = file;
				cl.position = codePos;
				cl.text = "LD HL,#" + std::to_string(variables.size() * 2 - i * 2 - 2);
				code.insert(code.begin() + codePos, cl);
				cl.text = "ADD HL,SP";
				code.insert(code.begin() + codePos + 1, cl);
				if (variables[i].second == 8)
				{
					cl.text = "INC HL";
					code.insert(code.begin() + codePos + 2, cl);
					cl.text = "LD B,(HL)";
					code.insert(code.begin() + codePos + 3, cl);
				}
				else if (variables[i].second == 16)
				{
					cl.text = "LD C,(HL)";
					code.insert(code.begin() + codePos + 2, cl);
					cl.text = "INC HL";
					code.insert(code.begin() + codePos + 3, cl);
					cl.text = "LD B,(HL)";
					code.insert(code.begin() + codePos + 4, cl);
				}
				return;
			}
		}
	}

	/// <summary>
	/// Loads code from file.
	/// </summary>
	/// <param name="path">Path to file</param>
	/// <param name="code">Result code</param>
	/// <returns>True if loaded, false otherwise</returns>
	inline bool loadFromFile(std::string path, std::vector<CodeLine> &code)
	{
		std::ifstream load(path);
		if (load.good() == false)
		{
			load.close();
			return false;
		}
		else
		{
			std::string line = "";
			int pos = 1;
			while (std::getline(load, line))
			{
				CodeLine cl;
				cl.position = pos;
				cl.removedNumber = 0;
				cl.text = line;
				cl.file = path;
				code.push_back(cl);
				pos++;
			}
		}
		load.close();
		return true;
	}

	/// <summary>
	/// Prepare instruction for preprocessor.
	/// </summary>
	/// <param name="instruction">Instruction</param>
	/// <returns>Prepared vector</returns>
	inline std::vector<std::string> preprocessingDividor(std::string instruction)
	{
		std::vector<std::string> res;
		res.push_back("");
		bool multipleSpaces = true;
		for (std::size_t i = 0; i < instruction.length(); i++)
		{
			if (instruction[i] == '\t')
				instruction[i] = ' ';
			if (instruction[i] == ' ')
			{
				if (multipleSpaces == false)
				{
					res.push_back("");
					multipleSpaces = true;
				}
				continue;
			}
			multipleSpaces = false;
			res.back().append(1, instruction[i]);
		}
		return res;
	}

	/// <summary>
	/// List of included files.
	/// </summary>
	static std::unordered_map<std::string, bool> includedFiles;

	/// <summary>
	/// Converts number in specified base to long.
	/// </summary>
	/// <param name="value">Text containing a number</param>
	/// <param name="line">Origin line</param>
	/// <param name="file">Origin file</param>
	/// <param name="showbadcode">Set true to show show erroneous code in error messages</param>
	/// <returns>Converted number</returns>
	inline unsigned long toLong(std::string &value, std::size_t &line, std::string &file, bool showbadcode)
	{
		if (value.length() == 0)
		{
			displayError("Number not specified.", "21", line, file, showbadcode, "Unable to provide bad code.");
			return 0;
		}
		int base = 0;
		if (value[0] == '#')
			base = 10;
		else if (value[0] == '$')
			base = 16;
		else if (value[0] == '%')
			base = 2;
		else
		{
			displayError("Number base not specified.", "22", line, file, showbadcode, "Unable to provide bad code.");
			return 0;
		}
		std::string temp = value.substr(1);
		for (char c : temp)
		{
			if (base == 10)
			{
				if (!std::isdigit(c))
				{
					displayError("Invalid character in decimal number.", "23", line, file, showbadcode, "Unable to provide bad code.");
					return 0;
				}
			}
			else if (base == 2)
			{
				if (c != '0' && c != '1')
				{
					displayError("Invalid character in binary number.", "24", line, file, showbadcode, "Unable to provide bad code.");
					return 0;
				}
			}
			else if (base == 16)
			{
				if (!std::isxdigit(c))
				{
					displayError("Invalid character in hexadecimal number.", "25", line, file, showbadcode, "Unable to provide bad code.");
					return 0;
				}
			}
		}

		unsigned long result = std::stoul(temp, nullptr, base);
		return result;
	}

	/// <summary>
	/// Executes preprocessor instruction.
	/// </summary>
	/// <param name="instruction">Instruction</param>
	/// <param name="defines">Map of defines</param>
	/// <param name="code">Assembly code</param>
	/// <param name="line">Origin line</param>
	/// <param name="file">Origin file</param>
	/// <param name="pos">Position in code</param>
	/// <param name="bytePos">Position in byte code</param>
	/// <param name="variables">Vector of variables</param>
	/// <param name="showbadcode">Set true to show show erroneous code in error messages</param>
	inline void preprocessing(std::string instruction, std::unordered_map<std::string, std::vector<std::string>> &defines, std::vector<CodeLine> &code, std::size_t &line, std::string &file, std::size_t &pos, std::size_t &bytePos, std::vector<std::pair<std::string, int>> &variables, bool showbadcode)
	{
		std::vector<std::string> data = preprocessingDividor(instruction);
		if (data[0] == ".include")
		{
			std::vector<CodeLine> temp;
			if (loadFromFile(data[1], temp) == false)
			{
				displayError("Unable to include file.", "404", line, file, showbadcode, instruction);
				return;
			}
			if (includedFiles.count(data[1]) > 0)
			{
				displayError("Duplicated file inclusion.", "405", line, file, showbadcode, instruction);
				return;
			}
			includedFiles.insert({data[1], true});
			for (std::size_t i = 0; i < temp.size(); i++)
			{
				code.insert(code.begin() + pos + i + 1, temp[i]);
			}
			return;
		}
		if (data[0] == ".define")
		{
			if (defines.count(data[1]) > 0)
			{
				displayError("Definition duplicate.", "16", line, file, showbadcode, instruction);
				return;
			}
			defines[data[1]].push_back(data[2]);
			return;
		}
		if (data[0] == ".macro")
		{
			if (defines.count(data[1]) > 0)
			{
				displayError("Macro duplicate.", "17", line, file, showbadcode, instruction);
				return;
			}
			while (true)
			{
				pos++;
				std::vector<std::string> subData = preprocessingDividor(code[pos].text);
				if (subData[0] == ".endmacro")
					break;
				defines[data[1]].push_back(code[pos].text);
			}
			return;
		}
		if (data[0] == ".org")
		{
			unsigned long newP = toLong(data[1], line, file, showbadcode);
			if (newP > std::numeric_limits<uint16_t>::max())
			{
				displayError("Org value exceeds max address.", "19", line, file, showbadcode, instruction);
				return;
			}
			bytePos = static_cast<std::size_t>(newP);
			return;
		}
		if (data[0] == ".var" || data[0] == ".new")
		{
			unsigned long declNum = toLong(data[3], line, file, showbadcode);
			if (data[1] == "word")
			{
				CodeLine cl;
				cl.file = file;
				cl.position = pos;
				cl.text = "LD BC,#" + std::to_string(declNum);
				code.insert(code.begin() + pos + 1, cl);
				cl.text = "PUSH BC";
				code.insert(code.begin() + pos + 2, cl);
				variables.push_back({data[2], 16});
			}
			else if (data[1] == "byte")
			{
				CodeLine cl;
				cl.file = file;
				cl.position = pos;
				cl.text = "LD B,#" + std::to_string(declNum);
				code.insert(code.begin() + pos + 1, cl);
				cl.text = "PUSH BC";
				code.insert(code.begin() + pos + 2, cl);
				variables.push_back({data[2], 8});
			}
			else
			{
				displayError("Variable declaration without size specified.", "54", line, file, showbadcode, instruction);
			}
			return;
		}
		if (data[0] == ".memclr" || data[0] == ".free")
		{
			unsigned long declNum = toLong(data[1], line, file, showbadcode);
			if (declNum <= variables.size())
			{
				CodeLine cl;
				cl.file = file;
				cl.position = pos;
				cl.text = "POP BC";
				for (unsigned long i = 0; i < declNum; i++)
				{
					code.insert(code.begin() + pos + i, cl);
					variables.pop_back();
				}
			}
			else
			{
				displayError("Variable deletion exceeds declarations.", "55", line, file, showbadcode, instruction);
			}
			return;
		}
	}

	/// <summary>
	/// Assembles code.
	/// </summary>
	/// <param name="code">Code</param>
	/// <param name="bytecode">Result machine code</param>
	/// <param name="startingPos">Starting position</param>
	/// <param name="showbadcode">Set true to show show erroneous code in error messages</param>
	/// <param name="beg0">Set to true if -alwaysbeginat0 was set</param>
	inline void assemble(std::vector<CodeLine> &code, std::vector<char> &bytecode, std::size_t startingPos, bool showbadcode, bool beg0)
	{
		std::unordered_map<std::string, uint16_t> labels;
		std::list<std::pair<std::size_t, uint16_t>> missingLabels;
		std::unordered_map<std::string, std::vector<std::string>> defines;
		std::vector<std::pair<std::string, int>> variables;
		std::string buf = "";

		std::size_t bytePos = startingPos;
		for (std::size_t i = 0; i < code.size(); i++)
		{
			insertDefines(code, defines, i, code[i].position, code[i].file, showbadcode);
			insertVariables(code, variables, i, code[i].position, code[i].file, showbadcode);
			code[i].text = lowercase(code[i].text);
			buf = code[i].text;
			bool label = false;
			bool labelDecl = false;
			bool preprocessor = false;
			std::string labelTxt = "";
			uint16_t num = formatCode(code[i].text, code[i].position, label, labelTxt, labelDecl, preprocessor, code[i].file, showbadcode);
			if (preprocessor == true)
			{
				preprocessing(code[i].text, defines, code, code[i].position, code[i].file, i, bytePos, variables, showbadcode);
				continue;
			}
			if (label == true)
			{
				if (labelDecl == true)
				{
					if (labels.count(labelTxt) != 0)
					{
						displayError("Non-unique label declaration.", "006", code[i].position, code[i].file, showbadcode, buf);
					}
					else
					{
						num = bytePos;
						labels.insert({labelTxt, bytePos});
					}
					code[i].text = buf;
					continue;
				}
				else if (labels.count(labelTxt) == 0)
				{
					num = 0;
					missingLabels.push_back({i, bytePos});
				}
				else
				{
					num = labels[labelTxt];
				}
			}
			if (opcodes.count(code[i].text) > 0)
			{
				uint32_t opC = 0;
				if (opcodes[code[i].text].second == 254)
				{
					opC = opcodes[code[i].text].first;
					opC += ((num & 0b11111111) << 8) + (num >> 8);
				}
				else
				{
					opC = opcodes[code[i].text].first + (opcodes[code[i].text].second == 255 ? 0 : (num << opcodes[code[i].text].second));
				}
				if (opC > 0b111111111111111111111111)
				{
					if (bytePos >= bytecode.size())
					{
						displayError("Program does not fit inside memory.", "47", code[i].position, code[i].file, showbadcode, buf);
						break;
					}
					if (bytecode[bytePos] != 0)
					{
						displayError("Org collision.", "44", code[i].position, code[i].file, showbadcode, buf);
					}
					bytecode[bytePos] = (opC >> 24) & 0b11111111;
					bytePos++;
				}
				if (opC > 0b1111111111111111)
				{
					if (bytePos >= bytecode.size())
					{
						displayError("Program does not fit inside memory.", "47", code[i].position, code[i].file, showbadcode, buf);
						break;
					}
					if (bytecode[bytePos] != 0)
					{
						displayError("Org collision.", "44", code[i].position, code[i].file, showbadcode, buf);
					}
					bytecode[bytePos] = (opC >> 16) & 0b11111111;
					bytePos++;
				}
				if ((opC > 0b11111111) || (opcodes[code[i].text].second == 254 && opC == 0))
				{
					if (bytePos >= bytecode.size())
					{
						displayError("Program does not fit inside memory.", "47", code[i].position, code[i].file, showbadcode, buf);
						break;
					}
					if (bytecode[bytePos] != 0)
					{
						displayError("Org collision.", "44", code[i].position, code[i].file, showbadcode, buf);
					}
					bytecode[bytePos] = (opC >> 8) & 0b11111111;
					bytePos++;
				}
				if (bytePos >= bytecode.size())
				{
					displayError("Program does not fit inside memory.", "47", code[i].position, code[i].file, showbadcode, buf);
					break;
				}
				if (bytecode[bytePos] != 0)
				{
					displayError("Org collision.", "44", code[i].position, code[i].file, showbadcode, buf);
				}
				bytecode[bytePos] = opC & 0b11111111;
				bytePos++;
			}
			else
			{
				if (code[i].text == "")
				{
					code[i].text = buf;
					continue;
				}
				displayError("Unknown instruction.", "002", code[i].position, code[i].file, showbadcode, buf);
			}
			code[i].text = buf;
		}
		for (auto it = missingLabels.begin(); it != missingLabels.end(); it++)
		{
			bool label = false;
			bool labelDecl = false;
			bool preprocessor = false;
			std::string labelTxt = "";
			std::string temp = "def_file";
			uint16_t num = formatCode(code[it->first].text, it->first, label, labelTxt, labelDecl, preprocessor, temp, showbadcode);
			if (labels.count(labelTxt) == 0)
			{
				displayError("Unknown label.", "003", it->first, temp, showbadcode, labelTxt);
			}
			else
			{
				if (it->second + 1 >= bytecode.size())
				{
					displayError("Program does not fit inside memory.", "47", it->first, temp, showbadcode, labelTxt);
					break;
				}
				if (bytecode[it->second] != 0)
				{
					if (it->second + 2 >= bytecode.size())
					{
						displayError("Program does not fit inside memory.", "47", it->first, temp, showbadcode, labelTxt);
						break;
					}
					bytecode[it->second + 1] += labels[labelTxt] & 0b11111111;
					bytecode[it->second + 2] += labels[labelTxt] >> 8;
				}
				else
				{
					bytecode[it->second] += labels[labelTxt] & 0b11111111;
					bytecode[it->second + 1] += labels[labelTxt] >> 8;
				}
			}
		}
		if (beg0 == true)
		{
			bool startMov = false;
			std::size_t offsetMov = 0;
			for (std::size_t i = 0; i < bytecode.size(); i++)
			{
				if (i >= bytecode.size())
				{
					displayError("Program does not fit inside memory.", "47", code[i].position, code[i].file, showbadcode, buf);
					break;
				}
				if (bytecode[i] != 0)
					startMov = true;
				else
				{
					offsetMov++;
					continue;
				}
				if (startMov == false)
					continue;
				bytecode[i - offsetMov] = bytecode[i];
			}
		}
	}

	/// <summary>
	/// Run program.
	/// </summary>
	/// <param name="in">Input file path</param>
	/// <param name="out">Output file path</param>
	/// <param name="mem">Target device memory size</param>
	/// <param name="startingPos">Starting position</param>
	/// <param name="showbadcode">Set true to show show erroneous code in error messages</param>
	/// <param name="beg0">Set to true if -alwaysbeginat0 was set</param>
	inline void run(std::string &in, std::string &out, std::string &mem, std::string &startingPos, bool showbadcode, bool beg0)
	{
		std::size_t sPos = 0;
		try
		{
			sPos = std::stol(startingPos);
		}
		catch (const std::exception &)
		{
			std::cout << "[WRN 002] Memory starting position unspecified. Assuming 0.\n";
			sPos = 0;
		}

		try
		{

			std::vector<CodeLine> code;
			std::vector<char> bytecode;
			if (mem == "64k")
				initializeBytecodeVector(bytecode, 65536);
			else if (mem == "48k")
				initializeBytecodeVector(bytecode, 49152);
			else if (mem == "32k")
				initializeBytecodeVector(bytecode, 32768);
			else if (mem == "16k")
				initializeBytecodeVector(bytecode, 16384);
			else if (mem == "8k")
				initializeBytecodeVector(bytecode, 8192);
			else if (mem == "4k")
				initializeBytecodeVector(bytecode, 4096);
			else if (mem == "2k")
				initializeBytecodeVector(bytecode, 2048);
			else if (mem == "1k")
				initializeBytecodeVector(bytecode, 1024);
			else
			{
				std::cout << "[WRN 001] Target memory size unspecified. Assuming 16kB.\n";
				initializeBytecodeVector(bytecode, 16384);
			}

			if (loadFromFile(in, code) == true)
			{
				assemble(code, bytecode, sPos, showbadcode, beg0);
				std::ofstream save(out, std::ios::binary);
				if (save.good() == false)
				{
					errCnt++;
					std::cout << "[ERR 005] Could not save output.\n";
				}
				else
				{
					if (errCnt > 0)
					{
						std::cout << "The program was not compiled - errors were encountered.\n";
					}
					else
					{
						for (std::size_t i = 0; i < bytecode.size(); i++)
						{
							save << bytecode[i];
						}
					}
				}
				save.close();
			}
			else
			{
				errCnt++;
				std::cout << "[ERR 004] Could not load input.\n";
			}
		}
		catch (const std::exception &e)
		{
			errCnt++;
			std::cout << "[ERR 000] Critical assembler exception: " << e.what() << "\n";
		}
	}
}